{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Maesh: Simpler Service Mesh \u00b6 Maesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Maesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh. Non-Invasive Service Mesh \u00b6 Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required. Prerequisites \u00b6 To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Welcome"},{"location":"#maesh-simpler-service-mesh","text":"Maesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Maesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.","title":"Maesh: Simpler Service Mesh"},{"location":"#non-invasive-service-mesh","text":"Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.","title":"Non-Invasive Service Mesh"},{"location":"#prerequisites","text":"To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Prerequisites"},{"location":"api/","text":"API \u00b6 Maesh includes a built-in API that can be used for debugging purposes. This can be useful when Maesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths: /api/configuration/current \u00b6 This endpoint provides raw json of the current configuration built by the controller. Note This may change each request, as it is a live data structure. /api/status/nodes \u00b6 This endpoint provides a json array containing some details about the readiness of the Maesh nodes visible by the controller This endpoint will still return a 200 if there are no visible nodes. /api/status/node/{maesh-pod-name}/configuration \u00b6 This endpoint provides raw json of the current configuration on the Maesh node with the pod name given in {maesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller. /api/status/readiness \u00b6 This endpoint returns a 200 response if the controller successfully deployed a configuration to all Maesh nodes, and Maesh is ready for use. Otherwise, it will return a 500. /api/log/deployment \u00b6 This endpoint provides a json array containing details about configuration deployments made by the controller. This array is currently capped at 1000 entries to avoid memory issues. If this is not enough, please open a github issue and we will look into updating this to be configurable.","title":"API"},{"location":"api/#api","text":"Maesh includes a built-in API that can be used for debugging purposes. This can be useful when Maesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths:","title":"API"},{"location":"api/#apiconfigurationcurrent","text":"This endpoint provides raw json of the current configuration built by the controller. Note This may change each request, as it is a live data structure.","title":"/api/configuration/current"},{"location":"api/#apistatusnodes","text":"This endpoint provides a json array containing some details about the readiness of the Maesh nodes visible by the controller This endpoint will still return a 200 if there are no visible nodes.","title":"/api/status/nodes"},{"location":"api/#apistatusnodemaesh-pod-nameconfiguration","text":"This endpoint provides raw json of the current configuration on the Maesh node with the pod name given in {maesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller.","title":"/api/status/node/{maesh-pod-name}/configuration"},{"location":"api/#apistatusreadiness","text":"This endpoint returns a 200 response if the controller successfully deployed a configuration to all Maesh nodes, and Maesh is ready for use. Otherwise, it will return a 500.","title":"/api/status/readiness"},{"location":"api/#apilogdeployment","text":"This endpoint provides a json array containing details about configuration deployments made by the controller. This array is currently capped at 1000 entries to avoid memory issues. If this is not enough, please open a github issue and we will look into updating this to be configurable.","title":"/api/log/deployment"},{"location":"configuration/","text":"Configuration \u00b6 The configuration for maesh is broken down into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the maesh service mesh is installed, and is configured via the values.yaml file in the helm install. Static configuration \u00b6 The maesh image version can be manually defined if needed, as can the version for the Traefik CE mesh nodes. Debug logging can be globally enabled. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Service Mesh Interface (SMI) mode can be enabled. This configures maesh to run in SMI mode, where access and routes are explicitly enabled. Note: By default, all routes and access is denied. Please see the SMI Specification for more information Dynamic configuration \u00b6 Dynamic configuration can be provided to Maesh using either annotations on kubernetes services (default mode) or SMI resources if Maesh is installed with SMI enabled . With Kubernetes Services \u00b6 Traffic type \u00b6 Annotations on services are the main way to configure maesh behavior. The service mode can be enabled by using the following annotation: maesh.containo.us/traffic-type: \"http\" This annotation can be set to either http or tcp , and will specify the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration. Scheme \u00b6 The scheme used to define custom scheme for request: maesh.containo.us/scheme: \"h2c\" This annotation can be set to either http , https or h2c and is available for maesh.containo.us/traffic-type: \"http\" . Limitations Please keep in mind, that if you set the scheme to https your service needs to expose itself via HTTPS as there is no mTLS in Maesh. Retry \u00b6 Retries can be enabled by using the following annotation: maesh.containo.us/retry-attempts: \"2\" This annotation sets the number of retry attempts that maesh will make if a network error occurrs. Please note that this value is a string, and needs to be quoted. Circuit breaker \u00b6 Circuit breaker can be enabled by using the following annotation: maesh.containo.us/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here Rate Limit \u00b6 Rate limiting can be enabled by using the following annotations: maesh.containo.us/ratelimit-average: \"100\" maesh.containo.us/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here With Service Mesh Interface \u00b6 Access Control \u00b6 The first step is to describe what the traffic of our server application looks like. --- apiVersion: specs.smi-spec.io/v1alpha1 kind: HTTPRouteGroup metadata: name: server-routes namespace: server matches: - name: api pathRegex: /api methods: [\"*\"] - name: metrics pathRegex: /metrics methods: [\"GET\"] In this example, we define a set of HTTP routes for our server application. More precisely, the server app is composed by two routes: The api route under the /api path, accepting all methods The metrics routes under the /metrics path, accepting only GET requests Other types of route groups and detailed information are available in the specification . By default, all traffic is denied so we need to grant access to clients to our application. This is done by defining a TrafficTarget . --- apiVersion: access.smi-spec.io/v1alpha1 kind: TrafficTarget metadata: name: client-server-target namespace: server destination: kind: ServiceAccount name: server namespace: server specs: - kind: HTTPRouteGroup name: server-routes matches: - api sources: - kind: ServiceAccount name: client namespace: client In this example, we grant access to all pods running with the service account client under the namespace client to the HTTP route api specified by on the group server-routes on all pods running with the service account server under the namespace server . Any client running with the service account client under the client namespace accessing server.server.maesh/api is allowed to access the /api resource. Others will receive 404 answers from the Maesh node. More information can be found in the SMI specification . Traffic Splitting \u00b6 SMI defines the TrafficSplit resource which allows to direct subsets of the traffic to different services. apiVersion: split.smi-spec.io/v1alpha1 kind: TrafficSplit metadata: name: server-split namespace server spec: service: server backends: - service: server-v1 weight: 80 - service: server-v2 weight: 20 In this example, we define a traffic split for our server service between two versions of our server, v1 and v2. server.server.maesh directs 80% of the traffic to the server-v1 pods, and 20% of the traffic to the server-v2 pods. More information can be found in the SMI specification . Traffic Metrics \u00b6 At the moment, Maesh does not implement the Traffic Metrics specification .","title":"Configuration"},{"location":"configuration/#configuration","text":"The configuration for maesh is broken down into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the maesh service mesh is installed, and is configured via the values.yaml file in the helm install.","title":"Configuration"},{"location":"configuration/#static-configuration","text":"The maesh image version can be manually defined if needed, as can the version for the Traefik CE mesh nodes. Debug logging can be globally enabled. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Service Mesh Interface (SMI) mode can be enabled. This configures maesh to run in SMI mode, where access and routes are explicitly enabled. Note: By default, all routes and access is denied. Please see the SMI Specification for more information","title":"Static configuration"},{"location":"configuration/#dynamic-configuration","text":"Dynamic configuration can be provided to Maesh using either annotations on kubernetes services (default mode) or SMI resources if Maesh is installed with SMI enabled .","title":"Dynamic configuration"},{"location":"configuration/#with-kubernetes-services","text":"","title":"With Kubernetes Services"},{"location":"configuration/#traffic-type","text":"Annotations on services are the main way to configure maesh behavior. The service mode can be enabled by using the following annotation: maesh.containo.us/traffic-type: \"http\" This annotation can be set to either http or tcp , and will specify the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration.","title":"Traffic type"},{"location":"configuration/#scheme","text":"The scheme used to define custom scheme for request: maesh.containo.us/scheme: \"h2c\" This annotation can be set to either http , https or h2c and is available for maesh.containo.us/traffic-type: \"http\" . Limitations Please keep in mind, that if you set the scheme to https your service needs to expose itself via HTTPS as there is no mTLS in Maesh.","title":"Scheme"},{"location":"configuration/#retry","text":"Retries can be enabled by using the following annotation: maesh.containo.us/retry-attempts: \"2\" This annotation sets the number of retry attempts that maesh will make if a network error occurrs. Please note that this value is a string, and needs to be quoted.","title":"Retry"},{"location":"configuration/#circuit-breaker","text":"Circuit breaker can be enabled by using the following annotation: maesh.containo.us/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here","title":"Circuit breaker"},{"location":"configuration/#rate-limit","text":"Rate limiting can be enabled by using the following annotations: maesh.containo.us/ratelimit-average: \"100\" maesh.containo.us/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here","title":"Rate Limit"},{"location":"configuration/#with-service-mesh-interface","text":"","title":"With Service Mesh Interface"},{"location":"configuration/#access-control","text":"The first step is to describe what the traffic of our server application looks like. --- apiVersion: specs.smi-spec.io/v1alpha1 kind: HTTPRouteGroup metadata: name: server-routes namespace: server matches: - name: api pathRegex: /api methods: [\"*\"] - name: metrics pathRegex: /metrics methods: [\"GET\"] In this example, we define a set of HTTP routes for our server application. More precisely, the server app is composed by two routes: The api route under the /api path, accepting all methods The metrics routes under the /metrics path, accepting only GET requests Other types of route groups and detailed information are available in the specification . By default, all traffic is denied so we need to grant access to clients to our application. This is done by defining a TrafficTarget . --- apiVersion: access.smi-spec.io/v1alpha1 kind: TrafficTarget metadata: name: client-server-target namespace: server destination: kind: ServiceAccount name: server namespace: server specs: - kind: HTTPRouteGroup name: server-routes matches: - api sources: - kind: ServiceAccount name: client namespace: client In this example, we grant access to all pods running with the service account client under the namespace client to the HTTP route api specified by on the group server-routes on all pods running with the service account server under the namespace server . Any client running with the service account client under the client namespace accessing server.server.maesh/api is allowed to access the /api resource. Others will receive 404 answers from the Maesh node. More information can be found in the SMI specification .","title":"Access Control"},{"location":"configuration/#traffic-splitting","text":"SMI defines the TrafficSplit resource which allows to direct subsets of the traffic to different services. apiVersion: split.smi-spec.io/v1alpha1 kind: TrafficSplit metadata: name: server-split namespace server spec: service: server backends: - service: server-v1 weight: 80 - service: server-v2 weight: 20 In this example, we define a traffic split for our server service between two versions of our server, v1 and v2. server.server.maesh directs 80% of the traffic to the server-v1 pods, and 20% of the traffic to the server-v2 pods. More information can be found in the SMI specification .","title":"Traffic Splitting"},{"location":"configuration/#traffic-metrics","text":"At the moment, Maesh does not implement the Traffic Metrics specification .","title":"Traffic Metrics"},{"location":"examples/","text":"Examples \u00b6 Here are some examples on how to easily deploy Maesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Maesh Simple Example \u00b6 Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml --- apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: containous/whoami:v1.4.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: containous/whoamitcp:latest imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Maesh by following this documentation on your cluster. Since Maesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Maesh since no X-Forwarded-For header should be added. Now, in order to configure Maesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have maesh.containo.us/traffic-type: \"http\" and the TCP service, maesh.containo.us/traffic-type: \"tcp\" . --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"http\" maesh.containo.us/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Maesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.maesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6","title":"Examples"},{"location":"examples/#examples","text":"Here are some examples on how to easily deploy Maesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Maesh","title":"Examples"},{"location":"examples/#simple-example","text":"Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml --- apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: containous/whoami:v1.4.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: containous/whoamitcp:latest imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Maesh by following this documentation on your cluster. Since Maesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Maesh since no X-Forwarded-For header should be added. Now, in order to configure Maesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have maesh.containo.us/traffic-type: \"http\" and the TCP service, maesh.containo.us/traffic-type: \"tcp\" . --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"http\" maesh.containo.us/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Maesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.maesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6","title":"Simple Example"},{"location":"install/","text":"Installation \u00b6 To install maesh, the installation method is quite simple: helm repo add maesh https://containous.github.io/maesh/charts helm repo update Install maesh helm chart: helm install maesh maesh/maesh Install from source \u00b6 To build the image locally, run: make to build the binary and build/tag the local image. Deploy helm chart \u00b6 Helm V3 Please keep in mind, that our current Helm Chart (v1.0.0) is v2 compatible only. The v3 compatible Chart will be released with v1.1 of Maesh. To deploy the helm chart, run: helm install maesh helm/chart/maesh --set controller.image.pullPolicy=IfNotPresent --set controller.image.tag=latest KubeDNS support \u00b6 Maesh can support KubeDNS helm install maesh maesh/maesh --set kubedns=true With this parameter Maesh will install a CoreDNS as a daemonset. KubeDNS will be patched with stubDomains Custom cluster domain \u00b6 If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install maesh maesh/maesh --set clusterDomain=my.custom.domain.com Service Mesh Interface \u00b6 Maesh supports the SMI specification which defines a set of custom resources to provide a fine-grained control over instrumentation, routing and access control of east-west communications. To enable SMI, install maesh in SMI mode by setting the smi.enable helm chart option to true. helm install maesh --namespace=maesh maesh/maesh --set smi.enable=true` The smi.enable option makes Maesh process SMI resources. Note Helm v3 automatically will install the CRDs in the /crds directory. If you are re-installing into a cluster with the CRDs already present, helm may give you a warning. If you do not want to install them, or want to avoid the warning during a re-install, please use the new --skip-crds flag. More informationcan be found on the helm documentation Platform recommendations \u00b6 Maesh will work on pretty much any kubernetes environment that conforms to the global kubernetes specification. That being said, we have had users encounter issues when using variants such as minikube, microk8s, and other development distributions. Maesh runs without issue on most public clouds (AWS, GKE, Azure, DigitalOcean, and more). If you want to run Maesh in development, we would recommend using k3s , as it is fully conformant. We use k3s in Maesh's integration tests, so you can be sure that it works properly. If you encounter issues on variants such as minikube or microk8s, please try and reproduce the issue on k3s. If you are unable to reproduce, it may be an issue with the distribution behaving differently than official kubernetes. Verify your installation \u00b6 You can check that Maesh has been installed properly by running the following command: Command kubectl get all -n maesh Expected Output NAME READY STATUS RESTARTS AGE pod/maesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/maesh-mesh-w62z5 1/1 Running 0 11s pod/maesh-mesh-zjlpf 1/1 Running 0 11s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/maesh-mesh-api ClusterIP 100.69.177.254 <none> 8080/TCP 29s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/maesh-mesh 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/maesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/maesh-controller-676fb86b89 1 1 0 28s Usage \u00b6 To use maesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.maesh . This will access the maesh service mesh, and will allow you to route requests through maesh. By default, maesh is opt-in, meaning you have to use the maesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Installation"},{"location":"install/#installation","text":"To install maesh, the installation method is quite simple: helm repo add maesh https://containous.github.io/maesh/charts helm repo update Install maesh helm chart: helm install maesh maesh/maesh","title":"Installation"},{"location":"install/#install-from-source","text":"To build the image locally, run: make to build the binary and build/tag the local image.","title":"Install from source"},{"location":"install/#deploy-helm-chart","text":"Helm V3 Please keep in mind, that our current Helm Chart (v1.0.0) is v2 compatible only. The v3 compatible Chart will be released with v1.1 of Maesh. To deploy the helm chart, run: helm install maesh helm/chart/maesh --set controller.image.pullPolicy=IfNotPresent --set controller.image.tag=latest","title":"Deploy helm chart"},{"location":"install/#kubedns-support","text":"Maesh can support KubeDNS helm install maesh maesh/maesh --set kubedns=true With this parameter Maesh will install a CoreDNS as a daemonset. KubeDNS will be patched with stubDomains","title":"KubeDNS support"},{"location":"install/#custom-cluster-domain","text":"If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install maesh maesh/maesh --set clusterDomain=my.custom.domain.com","title":"Custom cluster domain"},{"location":"install/#service-mesh-interface","text":"Maesh supports the SMI specification which defines a set of custom resources to provide a fine-grained control over instrumentation, routing and access control of east-west communications. To enable SMI, install maesh in SMI mode by setting the smi.enable helm chart option to true. helm install maesh --namespace=maesh maesh/maesh --set smi.enable=true` The smi.enable option makes Maesh process SMI resources. Note Helm v3 automatically will install the CRDs in the /crds directory. If you are re-installing into a cluster with the CRDs already present, helm may give you a warning. If you do not want to install them, or want to avoid the warning during a re-install, please use the new --skip-crds flag. More informationcan be found on the helm documentation","title":"Service Mesh Interface"},{"location":"install/#platform-recommendations","text":"Maesh will work on pretty much any kubernetes environment that conforms to the global kubernetes specification. That being said, we have had users encounter issues when using variants such as minikube, microk8s, and other development distributions. Maesh runs without issue on most public clouds (AWS, GKE, Azure, DigitalOcean, and more). If you want to run Maesh in development, we would recommend using k3s , as it is fully conformant. We use k3s in Maesh's integration tests, so you can be sure that it works properly. If you encounter issues on variants such as minikube or microk8s, please try and reproduce the issue on k3s. If you are unable to reproduce, it may be an issue with the distribution behaving differently than official kubernetes.","title":"Platform recommendations"},{"location":"install/#verify-your-installation","text":"You can check that Maesh has been installed properly by running the following command: Command kubectl get all -n maesh Expected Output NAME READY STATUS RESTARTS AGE pod/maesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/maesh-mesh-w62z5 1/1 Running 0 11s pod/maesh-mesh-zjlpf 1/1 Running 0 11s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/maesh-mesh-api ClusterIP 100.69.177.254 <none> 8080/TCP 29s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/maesh-mesh 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/maesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/maesh-controller-676fb86b89 1 1 0 28s","title":"Verify your installation"},{"location":"install/#usage","text":"To use maesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.maesh . This will access the maesh service mesh, and will allow you to route requests through maesh. By default, maesh is opt-in, meaning you have to use the maesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Usage"},{"location":"quickstart/","text":"Quickstart \u00b6 Maesh can be installed in your cluster without affecting any running services. It will safely install itself via the helm chart, and will be ready for use immediately after. Prerequisites \u00b6 Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3 RBAC \u00b6 Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions. kubeadm \u00b6 If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system Installing Maesh \u00b6 Command helm repo add maesh https://containous.github.io/maesh/charts helm repo update helm install maesh maesh/maesh Expected output [...] NOTES: Thank you for installing maesh. Your release is named maesh. To learn more about the release, try: $ helm status maesh $ helm get maesh Using Maesh \u00b6 As an example, let's deploy a server application and a client application under the maesh-test namespace. server.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: server namespace: maesh-test labels: app: server spec: replicas: 2 selector: matchLabels: app: server template: metadata: labels: app: server spec: containers: - name: server image: containous/whoami:v1.4.0 ports: - containerPort: 80 --- kind: Service apiVersion: v1 metadata: name: server namespace: maesh-test spec: selector: app: server ports: - name: web protocol: TCP port: 80 targetPort: 80 client.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: client namespace: maesh-test labels: app: client spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: giantswarm/tiny-tools:3.9 imagePullPolicy: IfNotPresent command: - \"sleep\" - \"infinity\" Create the namespace then deploy those two applications kubectl create namespace maesh-test kubectl apply -f server.yaml kubectl apply -f client.yaml You should now see the following output Command kubectl get all -n maesh-test Expected output NAME READY STATUS RESTARTS AGE pod/client-7446fdf848-x96fq 1/1 Running 0 79s pod/server-7c8fd58db5-rchg8 1/1 Running 0 77s pod/server-7c8fd58db5-sd4f9 1/1 Running 0 77s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/server ClusterIP 10.43.17.247 <none> 80/TCP 77s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/client 1/1 1 1 79s deployment.apps/server 2/2 2 2 77s NAME DESIRED CURRENT READY AGE replicaset.apps/client-7446fdf848 1 1 1 79s replicaset.apps/server-7c8fd58db5 2 2 2 77s Take note of the client app pod name (here it's client-7446fdf848-x96fq ) and open a new terminal session inside this pod using kubectl exec . kubectl -n maesh-test exec -ti client-7446fdf848-x96fq ash From inside the client container make sure you are able to reach your server using kubernetes DNS service discovery. Command curl server.maesh-test.svc.cluster.local Expected Output Hostname: server-7c8fd58db5-sd4f9 IP: 127.0.0.1 IP: ::1 IP: 10.42.2.10 IP: fe80::a4ec:77ff:fe37:1cdd RemoteAddr: 10.42.2.9:46078 GET / HTTP/1.1 Host: server.maesh-test.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* You can note that all this server application is doing is to respond with the content of the request it receives. Now replace the svc.cluster.local suffix by maesh , and tada: you are now using Maesh to reach your server! Command curl server.maesh-test.maesh Expected Output Hostname: server-7c8fd58db5-rchg8 IP: 127.0.0.1 IP: ::1 IP: 10.42.1.7 IP: fe80::601d:7cff:fe26:c8c6 RemoteAddr: 10.42.1.5:59478 GET / HTTP/1.1 Host: server.maesh-test.maesh User-Agent: curl/7.64.0 Accept: */* Accept-Encoding: gzip Uber-Trace-Id: 3f9e7129a059f70:7e889a1ebcb147ac:3f9e7129a059f70:1 X-Forwarded-For: 10.42.2.9 X-Forwarded-Host: server.maesh-test.maesh X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: maesh-mesh-w95q2 X-Real-Ip: 10.42.2.9 Note the presence of X-Forwarded headers as well as other instrumentation headers like Uber-Trace-Id , indicating than your request has been processed and instrumented by Maesh. What's next \u00b6 See the examples page to see a more advanced example, or dive into the configuration to discover all Maesh capabilities.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Maesh can be installed in your cluster without affecting any running services. It will safely install itself via the helm chart, and will be ready for use immediately after.","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Prerequisites"},{"location":"quickstart/#rbac","text":"Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions.","title":"RBAC"},{"location":"quickstart/#kubeadm","text":"If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system","title":"kubeadm"},{"location":"quickstart/#installing-maesh","text":"Command helm repo add maesh https://containous.github.io/maesh/charts helm repo update helm install maesh maesh/maesh Expected output [...] NOTES: Thank you for installing maesh. Your release is named maesh. To learn more about the release, try: $ helm status maesh $ helm get maesh","title":"Installing Maesh"},{"location":"quickstart/#using-maesh","text":"As an example, let's deploy a server application and a client application under the maesh-test namespace. server.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: server namespace: maesh-test labels: app: server spec: replicas: 2 selector: matchLabels: app: server template: metadata: labels: app: server spec: containers: - name: server image: containous/whoami:v1.4.0 ports: - containerPort: 80 --- kind: Service apiVersion: v1 metadata: name: server namespace: maesh-test spec: selector: app: server ports: - name: web protocol: TCP port: 80 targetPort: 80 client.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: client namespace: maesh-test labels: app: client spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: giantswarm/tiny-tools:3.9 imagePullPolicy: IfNotPresent command: - \"sleep\" - \"infinity\" Create the namespace then deploy those two applications kubectl create namespace maesh-test kubectl apply -f server.yaml kubectl apply -f client.yaml You should now see the following output Command kubectl get all -n maesh-test Expected output NAME READY STATUS RESTARTS AGE pod/client-7446fdf848-x96fq 1/1 Running 0 79s pod/server-7c8fd58db5-rchg8 1/1 Running 0 77s pod/server-7c8fd58db5-sd4f9 1/1 Running 0 77s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/server ClusterIP 10.43.17.247 <none> 80/TCP 77s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/client 1/1 1 1 79s deployment.apps/server 2/2 2 2 77s NAME DESIRED CURRENT READY AGE replicaset.apps/client-7446fdf848 1 1 1 79s replicaset.apps/server-7c8fd58db5 2 2 2 77s Take note of the client app pod name (here it's client-7446fdf848-x96fq ) and open a new terminal session inside this pod using kubectl exec . kubectl -n maesh-test exec -ti client-7446fdf848-x96fq ash From inside the client container make sure you are able to reach your server using kubernetes DNS service discovery. Command curl server.maesh-test.svc.cluster.local Expected Output Hostname: server-7c8fd58db5-sd4f9 IP: 127.0.0.1 IP: ::1 IP: 10.42.2.10 IP: fe80::a4ec:77ff:fe37:1cdd RemoteAddr: 10.42.2.9:46078 GET / HTTP/1.1 Host: server.maesh-test.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* You can note that all this server application is doing is to respond with the content of the request it receives. Now replace the svc.cluster.local suffix by maesh , and tada: you are now using Maesh to reach your server! Command curl server.maesh-test.maesh Expected Output Hostname: server-7c8fd58db5-rchg8 IP: 127.0.0.1 IP: ::1 IP: 10.42.1.7 IP: fe80::601d:7cff:fe26:c8c6 RemoteAddr: 10.42.1.5:59478 GET / HTTP/1.1 Host: server.maesh-test.maesh User-Agent: curl/7.64.0 Accept: */* Accept-Encoding: gzip Uber-Trace-Id: 3f9e7129a059f70:7e889a1ebcb147ac:3f9e7129a059f70:1 X-Forwarded-For: 10.42.2.9 X-Forwarded-Host: server.maesh-test.maesh X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: maesh-mesh-w95q2 X-Real-Ip: 10.42.2.9 Note the presence of X-Forwarded headers as well as other instrumentation headers like Uber-Trace-Id , indicating than your request has been processed and instrumented by Maesh.","title":"Using Maesh"},{"location":"quickstart/#whats-next","text":"See the examples page to see a more advanced example, or dive into the configuration to discover all Maesh capabilities.","title":"What's next"}]}